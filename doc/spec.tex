\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[letterpaper,margin=1in]{geometry}
\usepackage[parfill]{parskip}
\usepackage{mathtools}
\usepackage{amssymb}
\usepackage{mathpartir}
\title{Birb}
\author{Ariel Davis (azdavis), Vivian Huang (vivianh)}
\date{\today}
\begin{document}
\maketitle

This is the specification for Birb, a programming language featuring an effects
system and channels.

\newpage
\section{AST}

We introduce sorts for kinds, types, effects, values, and computations.

When there is an $i$ subscript, the idea is that there are 0 or more of the
thing with the subscript. This means we allow for:
\begin{itemize}
\item the empty product effect (``pure'')
\item the empty product type (``unit'')
\item the empty product literal (also ``unit'')
\item the empty sum type (``void'' or ``never'')
\item the empty case analysis
\end{itemize}

Note that the empty case analysis, when used on a value of empty sum type, is a
computation with any type -- but that's fine, since there are no values of empty
sum type.

This abstract syntax introduces a modal separation between values and
computations, but an ideal concrete syntax would make the distinction as
unintrusive as possible. We don't want to have to be explicitly sequencing and
\textsf{pure}ing all over the place in the concrete syntax.

The interplay of type lambdas, forall types, and kinds is inspired by System
$F_\omega$.

Many constructs were somewhat duplicated in both the type and effect sorts, to
allow for genericity over both types and effects. But note that the big-lambda
function in the value sort works for both generic types and generic effects,
even though we suggestively use $t$ as the variable name.

\[
\begin{array}{l r l l}
\textsf{Kind} & \kappa ::= & \textsf{Type}                     & \text{type} \\
              &            & \textsf{Eff}                      & \text{effect} \\
              &            & \kappa_1 \rightarrow \kappa_2     & \text{arrow} \\
\\
\textsf{Type} &   \tau ::= & t                                 & \text{variable} \\
              &            & \textsf{Nat}                      & \text{natural number} \\
              &            & \textsf{Str}                      & \text{string} \\
              &            & \langle L_i : \tau_i \rangle      & \text{labeled product} \\
              &            & [ L_i : \tau_i ]                  & \text{labeled sum} \\
              &            & \tau_1 \rightarrow \tau_2!E       & \text{arrow} \\
              &            & \forall (t : \kappa) \ \tau       & \text{universal} \\
              &            & \lambda (t : \kappa) \ \tau       & \text{function} \\
              &            & \tau_1[\tau_2]                    & \text{application} \\
              &            & \textsf{Sender}[\tau]             & \text{channel sender} \\
              &            & \textsf{Receiver}[\tau]           & \text{channel receiver} \\
\\
\textsf{Eff}  &      E ::= & e                                 & \text{variable} \\
              &            & \langle L_i :
                             \tau_{i,1}
                             \rightarrow \tau_{i,2}
                             \rangle                           & \text{labeled product} \\
              &            & \forall (e : \kappa) \ E          & \text{universal} \\
              &            & \lambda (e : \kappa) \ E          & \text{function} \\
              &            & E_1[E_2]                          & \text{application} \\
\\
\textsf{Val}  &      v ::= & x                                 & \text{variable} \\
              &            & \overline{n}                      & \text{natural number} \\
              &            & \overline{s}                      & \text{string} \\
              &            & \langle
                             L_i \hookrightarrow v_i
                             \rangle                           & \text{labeled product} \\
              &            & L \cdot v                         & \text{labeled sum} \\
              &            & \lambda (x : \tau) \ c            & \text{function} \\
              &            & \Lambda (t : \kappa) \ v          & \text{big function} \\
\\
\textsf{Comp} &      c ::= & \textsf{pure} \ v                 & \text{enter the monad} \\
              &            & \textsf{bind} \ x \leftarrow c_1
                             \ \textsf{in} \ c_2               & \text{sequencing} \\
              &            & v \cdot L                         & \text{projection} \\
              &            & \textsf{match} \ v \ \{
                             L_i \cdot x_i \hookrightarrow c_i
                             \}                                & \text{case analysis} \\
              &            & v_1(v_2)                          & \text{value application} \\
              &            & v[\tau]                           & \text{type application} \\
              &            & v[E]                              & \text{effect application} \\
              &            & \textsf{newchan}[\tau]            & \text{channel creation} \\
              &            & \textsf{send}(v)                  & \text{channel send} \\
              &            & \textsf{recv}(v)                  & \text{channel receive} \\
\end{array}
\]

\newpage
\section{Judgement Form}

We introduce the judgements
\begin{enumerate}
\item $\Gamma \vdash \tau : \kappa$, the kinding judgement for types.
\item $\Gamma \vdash E : \kappa$, the kinding judgement for effects.
\item $\Gamma \vdash v : \tau$, the typing judgement for values, which do not
step and do not engender effects.
\item $\Gamma \vdash c : \tau!E$, the typing judgement for computations, which
do step and may engender effects.
\item $c \mapsto c'$, the stepping judgement for computations.
\end{enumerate}

\newpage
\section{Sample Rules}

\subsection{$\Gamma \vdash \tau : \kappa$}

\begin{mathpar}
\inferrule*[right=T-Var]{
  % axiom
}{
  \Gamma, t : \kappa \vdash t : \kappa
}

\inferrule*[right=T-Nat]{
  % axiom
}{
  \Gamma \vdash \textsf{Nat} : \textsf{Type}
}

\inferrule*[right=T-Str]{
  % axiom
}{
  \Gamma \vdash \textsf{Str} : \textsf{Type}
}

\inferrule*[right=T-Prod]{
  (\forall i) \ \Gamma \vdash \tau_i : \textsf{Type}
}{
  \Gamma \vdash \langle L_i : \tau_i \rangle : \textsf{Type}
}

\inferrule*[right=T-Sum]{
  (\forall i) \ \Gamma \vdash \tau_i : \textsf{Type}
}{
  \Gamma \vdash [ L_i : \tau_i ] : \textsf{Type}
}

\inferrule*[right=T-Arrow]{
  \Gamma \vdash \tau_1 : \textsf{Type} \\
  \Gamma \vdash \tau_2 : \textsf{Type} \\
  \Gamma \vdash E : \textsf{Eff}
}{
  \Gamma \vdash \tau_1 \rightarrow \tau_2!E : \textsf{Type}
}

\inferrule*[right=T-Forall]{
  \Gamma, t : \kappa \vdash \tau : \textsf{Type}
}{
  \Gamma \vdash \forall (t : \kappa) \ \tau : \textsf{Type}
}

\inferrule*[right=T-Func]{
  \Gamma, t : \kappa_1 \vdash \tau : \kappa_2
}{
  \Gamma \vdash \lambda (t : \kappa_1) \ \tau : \kappa_1 \rightarrow \kappa_2
}

\inferrule*[right=T-App]{
  \Gamma \vdash \tau_1 : \kappa_1 \rightarrow \kappa_2 \\
  \Gamma \vdash \tau_2 : \kappa_1
}{
  \Gamma \vdash \tau_1[\tau_2] : \kappa_2
}

\inferrule*[right=T-Sender]{
  \Gamma \vdash \tau : \textsf{Type}
}{
  \Gamma \vdash \textsf{Sender}[\tau] : \textsf{Type}
}

\inferrule*[right=T-Receiver]{
  \Gamma \vdash \tau : \textsf{Type}
}{
  \Gamma \vdash \textsf{Receiver}[\tau] : \textsf{Type}
}
\end{mathpar}

\subsection{$\Gamma \vdash E : \kappa$}

\begin{mathpar}
\inferrule*[right=E-Var]{
  % axiom
}{
  \Gamma, e : \kappa \vdash e : \kappa
}

\inferrule*[right=E-Prod]{
  (\forall i) \ \Gamma \vdash \tau_{i,1} : \textsf{Type} \\
  (\forall i) \ \Gamma \vdash \tau_{i,2} : \textsf{Type} \\
}{
  \Gamma \vdash
  \langle L_i : \tau_{i,1} \rightarrow \tau_{i,2} \rangle
  : \textsf{Eff}
}

\inferrule*[right=E-Forall]{
  \Gamma, e : \kappa \vdash E : \textsf{Eff}
}{
  \Gamma \vdash \forall (e : \kappa) \ E : \textsf{Eff}
}

\inferrule*[right=E-Func]{
  \Gamma, t : \kappa_1 \vdash E : \kappa_2
}{
  \Gamma \vdash \lambda (t : \kappa_1) \ E : \kappa_1 \rightarrow \kappa_2
}

\inferrule*[right=E-App]{
  \Gamma \vdash E_1 : \kappa_1 \rightarrow \kappa_2 \\
  \Gamma \vdash E_2 : \kappa_1
}{
  \Gamma \vdash E_1[E_2] : \kappa_2
}
\end{mathpar}

\subsection{$\Gamma \vdash v : \tau$}

\begin{mathpar}
\inferrule*[right=V-Var]{
  % axiom
}{
  \Gamma, x : \tau \vdash x : \tau
}

\inferrule*[right=V-Nat]{
  % axiom
}{
  \Gamma \vdash \overline{n} : \textsf{Nat}
}

\inferrule*[right=V-Str]{
  % axiom
}{
  \Gamma \vdash \overline{s} : \textsf{Str}
}

\inferrule*[right=V-Prod]{
  (\forall i) \ \Gamma \vdash v_i : \tau_i
}{
  \Gamma \vdash \langle L_i \hookrightarrow v_i \rangle :
  \langle L_i : \tau_i \rangle
}

\inferrule*[right=V-Sum]{
  (\exists j, 0 \leq j \leq i) \ \Gamma \vdash v : \tau_j
}{
  \Gamma \vdash L_j \cdot v : [ L_i : \tau_i ]
}

\inferrule*[right=V-Func]{
  \Gamma \vdash \tau_1 : \textsf{Type} \\
  \Gamma, x : \tau_1 \vdash c : \tau_2!E
}{
  \Gamma \vdash \lambda (x : \tau_1) \ c : \tau_1 \rightarrow \tau_2!E
}

\inferrule*[right=V-BigFunc]{
  \Gamma, t : \kappa \vdash v : \tau
}{
  \Gamma \vdash \Lambda (t : \kappa) \ v : \forall (t : \kappa) \ \tau
}
\end{mathpar}

TODO define union of effects?

\subsection{$\Gamma \vdash c : \tau!E$}

\begin{mathpar}
\inferrule*[right=C-Pure]{
  \Gamma \vdash v : \tau
}{
  \Gamma \vdash \textsf{pure} \ v : \tau!\langle \rangle
}

\inferrule*[right=C-Bind]{
  \Gamma \vdash c_1 : \tau_1!E_1 \\
  \Gamma, x : \tau_1 \vdash c_2 : \tau_2!E_2 \\
  E = E_1 \cup E_2
}{
  \Gamma \vdash \textsf{bind} \ x \leftarrow c_1 \ \textsf{in} \ c_2 :
  \tau_2!E
}

\inferrule*[right=C-Proj]{
  \Gamma \vdash v : \langle L_i : \tau_i \rangle \\
  \exists j, 0 \leq j \leq i
}{
  \Gamma \vdash v \cdot L_j : \tau_j!\langle \rangle
}

\inferrule*[right=C-Match]{
  \Gamma \vdash v : [ L_i : \tau_i ] \\
  (\forall i) \ \Gamma, x_i : \tau_i \vdash c_i : \tau!E_i \\
  E = \bigcup E_i
}{
  \Gamma \vdash \textsf{match} \ v \ \{
  L_i \cdot x_i \hookrightarrow c_i
  \} : \tau!E
}

\inferrule*[right=C-App]{
  \Gamma \vdash v_1 : \tau_1 \rightarrow \tau_2!E \\
  \Gamma \vdash v_2 : \tau_1
}{
  \Gamma \vdash v_1(v_2) : \tau_2!E
}

\inferrule*[right=C-TypeApp]{
  \Gamma \vdash v : \forall (t : \kappa) \ \tau_2 \\
  \Gamma \vdash \tau_1 : \kappa
}{
  \Gamma \vdash v[\tau_1] : ([\tau_1/t] \tau_2)!\langle \rangle
}

\inferrule*[right=C-EffApp]{
  \Gamma \vdash v : \forall (e : \kappa) \ E_2 \\
  \Gamma \vdash E_1 : \kappa
}{
  \Gamma \vdash v[E_1] : ([E_1/e] E_2)!\langle \rangle
}

\inferrule*[right=C-ChanNew]{
  \Gamma \vdash \tau : \textsf{Type}
}{
  \Gamma \vdash \textsf{newchan}[\tau] :
  \langle 1 : \textsf{Sender}[\tau], 2 : \textsf{Receiver}[\tau] \rangle
  !
  \langle \textsf{newchan} : \langle \rangle \rightarrow \textsf{Nat} \rangle
}

\inferrule*[right=C-ChanSend]{
  \Gamma \vdash v : \langle 1 : \textsf{Sender}[\tau], 2 : \tau \rangle
}{
  \Gamma \vdash \textsf{send}(v) :
  \textsf{Sender}[\tau]
  !
  \langle
    \textsf{send} :
      \langle 1 : \textsf{Nat}, 2 : \tau \rangle
      \rightarrow \langle \rangle
  \rangle
}

\inferrule*[right=C-ChanRecv]{
  \Gamma \vdash v : \textsf{Receiver}[\tau]
}{
  \Gamma \vdash \textsf{recv}(v) :
  \langle 1 : \textsf{Receiver}[\tau], 2 : \tau \rangle
  !
  \langle \textsf{recv} : \textsf{Nat} \rightarrow \tau \rangle
}
\end{mathpar}

\subsection{$c \mapsto c'$}

\begin{mathpar}
\inferrule*[right=S-BindArg]{
  c_1 \mapsto c_1'
}{
  \textsf{bind} \ x \leftarrow c_1 \ \textsf{in} \ c_2
  \mapsto
  \textsf{bind} \ x \leftarrow c_1' \ \textsf{in} \ c_2
}

\inferrule*[right=S-Bind]{
  % axiom
}{
  \textsf{bind} \ x \leftarrow \textsf{pure} \ v \ \textsf{in} \ c_2
  \mapsto
  [v/x] c_2
}

\inferrule*[right=S-Proj]{
  \exists j, 0 \leq j \leq i
}{
  \langle L_i \hookrightarrow v_i \rangle \cdot L_j \mapsto \textsf{pure} \ v_j
}

\inferrule*[right=S-Match]{
  \exists j, 0 \leq j \leq i
}{
  \textsf{match} \ L_j \cdot v \ \{
    L_i \cdot x_i \hookrightarrow c_i
  \}
  \mapsto
  [v/x_j] c_j
}

\inferrule*[right=S-App]{
  % axiom
}{
  (\lambda (x : \tau) c) (v_2) \mapsto [v_2/x] c
}

\inferrule*[right=S-TypeApp]{
  % axiom
}{
  (\Lambda (t : \kappa) v)[\tau] \mapsto \textsf{pure} \ [\tau/t] v
}

\inferrule*[right=S-EffApp]{
  % axiom
}{
  (\Lambda (t : \kappa) v)[E] \mapsto \textsf{pure} \ [E/t] v
}
\end{mathpar}

TODO add rules for newchan, send, recv

TODO define subst?

\newpage
\section{Safety}

The following theorems ought to hold:

\begin{itemize}
\item (Progress) If $\Gamma \vdash c : \tau!E$, then $c = \textsf{pure} \ v$ or
$c \mapsto c'$.
\item (Preservation) If $\Gamma \vdash c : \tau!E$ and $c \mapsto c'$, then
$\Gamma \vdash c' : \tau!E'$ where $E' \subseteq E$.
\end{itemize}

TODO define subset relation for effects?

\end{document}
